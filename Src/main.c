/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "rcc.h"
#include "flash.h"
#include "gpio.h"
#include "usart.h"
#include "nvic.h"
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "timer.h"
#include "dma.h"

/* Timer configuration constants for STM32F407VG TIM2 */
#define TIM_PRESCALER 84 // Assuming 84 MHz APB1 clock, prescaler for 1 MHz tick
#define TIM_PERIOD 1000 // 1 MHz / 1000 = 1 kHz update rate (1 ms period)
#define TIM_CLOCK_DIVISION 0 // No clock division
#define TIM_ALIGNMENT_EDGE 0 // Edge-aligned mode
#define TIM_DIRECTION_UP 0 // Upcounting direction
#define TIM_DMA_UPDATE 0x1 // DMA on update event (vendor-specific assumption)

/* DMA configuration constants for STM32F407VG DMA1 Stream 5 */
#define DMA1_STREAM5_IRQN 15 // DMA1 Stream 5 IRQ number
#define DMA_INTERRUPT_PRIORITY 7 // Priority level (0-15, lower is higher priority)
#define DMA1_STREAM 5 // DMA1 Stream 5 for TIM2 update
#define DMA_CHANNEL 3 // Channel 3 for TIM2 update event
#define GPIOB_IDR_ADDRESS 0x40020410 // GPIOB input data register
#define DMA_BUFFER_SIZE 256 // Circular buffer size (16-bit words)
#define DMA_TRANSFER_MODE_PERIPH_TO_MEM 0 // Peripheral-to-memory direction
#define DMA_MEMORY_SIZE_16BIT 1 // 16-bit memory size
#define DMA_PERIPHERAL_SIZE_16BIT 1 // 16-bit peripheral size
#define DMA_PRIORITY_HIGH 2 // High priority
//#define DMA_TCIF 0x1 // Transfer complete interrupt flag (assumed)
//#define DMA_HTIF 0x2 // Half-transfer interrupt flag (assumed)

/* Circular buffer structure */
typedef struct {
    uint16_t data[DMA_BUFFER_SIZE]; // Buffer storage
    uint16_t head; // Index of next write (updated by DMA)
    bool half_transfer; // Flag for half-transfer interrupt
    bool full_transfer; // Flag for full-transfer interrupt
} CircularBuffer;

// Global circular buffer instance
static CircularBuffer dma_buffer = {
    .data = {0},
    .head = 0,
    .half_transfer = false,
    .full_transfer = false
};

/**
 * @brief Initializes DMA1 Stream 5 for TIM2-triggered transfer from GPIOB to circular buffer
 * @param dma DMA peripheral base address (e.g., DMA1)
 * @return bool True if initialization successful, false otherwise
 */
bool dma_init(uint32_t dma) {
    // Validate input parameters
    if (dma == 0) {
        return false;
    }

    // Reset DMA stream
    dma_stream_reset(dma, DMA1_STREAM);

    // Configure DMA transfer parameters
    dma_set_transfer_mode(dma, DMA1_STREAM, DMA_TRANSFER_MODE_PERIPH_TO_MEM);
    dma_set_priority(dma, DMA1_STREAM, DMA_PRIORITY_HIGH);
    dma_set_memory_size(dma, DMA1_STREAM, DMA_MEMORY_SIZE_16BIT);
    dma_set_peripheral_size(dma, DMA1_STREAM, DMA_PERIPHERAL_SIZE_16BIT);
    dma_enable_memory_increment_mode(dma, DMA1_STREAM); // Increment memory address
    dma_disable_peripheral_increment_mode(dma, DMA1_STREAM); // Fixed peripheral address
    dma_enable_circular_mode(dma, DMA1_STREAM); // Continuous transfers
    dma_channel_select(dma, DMA1_STREAM, DMA_CHANNEL); // TIM2 update channel

    // Set source and destination addresses
    dma_set_peripheral_address(dma, DMA1_STREAM, GPIOB_IDR_ADDRESS);
    dma_set_memory_address(dma, DMA1_STREAM, (uint32_t)dma_buffer.data);
    dma_set_number_of_data(dma, DMA1_STREAM, DMA_BUFFER_SIZE);

    // Enable half-transfer and transfer-complete interrupts
    dma_enable_half_transfer_interrupt(dma, DMA1_STREAM);
    dma_enable_transfer_complete_interrupt(dma, DMA1_STREAM);

    // Configure NVIC for DMA1 Stream 5 interrupt
    nvic_set_priority(DMA1_STREAM5_IRQN, DMA_INTERRUPT_PRIORITY);
    nvic_clear_pending_irq(DMA1_STREAM5_IRQN); // Clear pending interrupts
    nvic_enable_irq(DMA1_STREAM5_IRQN); // Enable interrupt in NVIC

    // Enable DMA stream
    dma_enable_stream(dma, DMA1_STREAM);

    // Verify configuration
    if (!nvic_get_irq_enabled(DMA1_STREAM5_IRQN) ||
        dma_get_number_of_data(dma, DMA1_STREAM) != DMA_BUFFER_SIZE) {
        dma_disable_stream(dma, DMA1_STREAM);
        nvic_disable_irq(DMA1_STREAM5_IRQN);
        return false;
    }

    return true;
}

/**
 * @brief DMA1 Stream 5 interrupt handler
 */
void DMA1_Stream5_IRQHandler(void) {
    // Check and handle half-transfer interrupt
    if (dma_get_interrupt_flag(DMA1, DMA1_STREAM, DMA_HTIF)) {
        dma_clear_interrupt_flags(DMA1, DMA1_STREAM, DMA_HTIF);
        dma_buffer.half_transfer = true;
        dma_buffer.head = DMA_BUFFER_SIZE / 2; // Update head for half buffer
    }

    // Check and handle transfer-complete interrupt
    if (dma_get_interrupt_flag(DMA1, DMA1_STREAM, DMA_TCIF)) {
        dma_clear_interrupt_flags(DMA1, DMA1_STREAM, DMA_TCIF);
        dma_buffer.full_transfer = true;
        dma_buffer.head = 0; // Reset head for full buffer
    }

    // User code can check dma_buffer.half_transfer or dma_buffer.full_transfer
    // to process data from dma_buffer.data[0:DMA_BUFFER_SIZE/2] or [DMA_BUFFER_SIZE/2:DMA_BUFFER_SIZE]
}


/**
 * @brief Initializes TIM2 as a 32-bit upcounting timer with DMA update event
 * @param timer_peripheral TIM2 peripheral base address
 * @return bool True if initialization successful, false otherwise
 */
bool timer_init(uint32_t timer_peripheral) {
    // Validate input parameters
    if (timer_peripheral == 0) {
        return false;
    }

    // Disable timer before configuration
    timer_disable_counter(timer_peripheral);

    // Configure timer mode: upcounting, edge-aligned
    timer_set_mode(timer_peripheral, TIM_CLOCK_DIVISION, TIM_ALIGNMENT_EDGE, TIM_DIRECTION_UP);
    timer_continuous_mode(timer_peripheral); // Ensure repetitive operation
    timer_update_on_overflow(timer_peripheral); // Update event on overflow

    // Set prescaler and period for 1 kHz update rate
    timer_set_prescaler(timer_peripheral, TIM_PRESCALER - 1); // Prescaler is 0-based
    timer_set_period(timer_peripheral, TIM_PERIOD - 1); // Period is 0-based

    // Enable preload for stable updates
    timer_enable_preload(timer_peripheral);

    // Configure DMA on update event
    timer_set_dma_on_update_event(timer_peripheral);

    // Start the timer
    timer_enable_counter(timer_peripheral);

    // Verify timer is running (basic check)
    if (timer_get_counter(timer_peripheral) == 0) {
        timer_disable_counter(timer_peripheral);
        return false;
    }

    return true;
}


#define UART_BAUDRATE 115200
#define UART_DATABITS 8
#define UART_STOPBITS 1

#define USART1_IRQN 37
#define UART_INTERRUPT_PRIORITY 5 // Priority level (0-15, lower is higher priority)



void clock_setup(void) {
    // Enable HSE and wait for it to be ready
    rcc_osc_on(RCC_HSE);
    rcc_wait_for_osc_ready(RCC_HSE);

    // Apply the predefined 84 MHz configuration (includes flash settings)
    rcc_clock_setup_pll(&rcc_hse_8mhz_3v3[RCC_CLOCK_3V3_84MHZ]);

    // Enable peripheral clocks (example: GPIOA and USART1)
    rcc_periph_clock_enable(RCC_GPIOA);
    rcc_periph_clock_enable(RCC_USART1);
    rcc_periph_clock_enable(RCC_TIM2);
    rcc_periph_clock_enable(RCC_DMA1);

}


void gpio_setup(void) {
    // Configure PA9 (TX) and PA10 (RX) as alternate function for USART1
    gpio_mode_setup(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO9 | GPIO10);
    gpio_set_af(GPIOA, GPIO_AF7, GPIO9 | GPIO10); // AF7 for USART1


     gpio_mode_setup(GPIOA, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO5);
}

bool usart_setup(void) {
    // Set baud rate to 115200
    usart_set_baudrate(USART1, UART_BAUDRATE);

    // Set 8 data bits
    usart_set_databits(USART1, UART_DATABITS);

    // Set 1 stop bit
    usart_set_stopbits(USART1, USART_STOPBITS_1);

    // Set no parity
    usart_set_parity(USART1, USART_PARITY_NONE);

    // Set TX/RX mode
    usart_set_mode(USART1, USART_MODE_TX_RX);

    // Set no hardware flow control
    usart_set_flow_control(USART1, USART_FLOWCONTROL_NONE);

    // Enable receive interrupt
        usart_enable_rx_interrupt(USART1);

        // Disable other interrupts to prevent unwanted triggers
        usart_disable_tx_interrupt(USART1);
        usart_disable_tx_complete_interrupt(USART1);
        usart_disable_idle_interrupt(USART1);
        usart_disable_error_interrupt(USART1);

        // Disable DMA to ensure standard operation
        usart_disable_rx_dma(USART1);
        usart_disable_tx_dma(USART1);

        // Configure NVIC for USART2 interrupt
          nvic_set_priority(USART1_IRQN, UART_INTERRUPT_PRIORITY);
          nvic_clear_pending_irq(USART1_IRQN); // Clear any pending interrupts
          nvic_enable_irq(USART1_IRQN);        // Enable interrupt in NVIC

        // Enable UART
        usart_enable(USART1);
        // Verify configuration
            if (usart_get_databits(USART1) != UART_DATABITS ||
                usart_get_stopbits(USART1) != UART_STOPBITS ||
                usart_get_parity(USART1) != USART_PARITY_NONE) {
                usart_disable(USART1);
                return false;
            }

            return true;

    // Enable USART1
    usart_enable(USART1);
}

// Stack sizes in words
#define ACQUISITION_TASK_STACK_SIZE      (128U)
#define PROCESSING_TASK_STACK_SIZE       (256U)
#define COMM_TASK_STACK_SIZE             (128U)

// Task priorities
#define ACQUISITION_TASK_PRIORITY        (configMAX_PRIORITIES - 1)
#define PROCESSING_TASK_PRIORITY         (configMAX_PRIORITIES - 2)
#define COMM_TASK_PRIORITY               (configMAX_PRIORITIES - 3)

// Task handles
static TaskHandle_t acquisitionTaskHandle = NULL;
static TaskHandle_t processingTaskHandle  = NULL;
static TaskHandle_t commTaskHandle        = NULL;

//SEMAPHORE TO TAKE AND GIVE ACCES TO THE TASK
static SemaphoreHandle_t dmaSemaphore = NULL;


//queue handle
#define QUEUE_LENGTH 10
#define ITEM_SIZE sizeof(B)  // Custom type holding your buffer

//typedef struct {
//    uint16_t data[DMA_BUFFER_SIZE];  // or pointer if using double buffering
//    uint16_t timestamp;             // optional: timer capture value
//} DMA_Buffer_t;

typedef struct{
	bool port_state;
	uint16_t timestamp;
}pinstate;

pinstate B;

//DMA_Buffer_t dmadata;
QueueHandle_t dmaQueue[16];

#define PROTOCAL_STRUCT_SIZE sizeof(uart_packet_t)

typedef struct {
    uint8_t command_id;      /**< Command or Data type ID */
    uint16_t payload_length; /**< Length of payload in bytes */
    uint8_t payload[8];     /**< Actual payload data */
    uint16_t crc;            /**< CRC-16 over command + payload */
} uart_packet_t;

QueueHandle_t uartQueue;


// Function prototypes
 void AcquisitionTask(void *pvParameters);
 void ProcessingTask(void *pvParameters);
 void CommunicationTask(void *pvParameters);

void AcquisitionTask(void *pvParameters)
{
	uint16_t i;
	for (;;)
	    {
	        // Wait for DMA signal (from ISR)
	        if (xSemaphoreTake(dmaSemaphore, portMAX_DELAY) == pdTRUE)
	        {
	            // DMA has filled the buffer, process it
	           // process_buffer_data();

	        	for(i=dma_buffer.head;i<=128;i++){

	        		for (uint8_t j = 0; j < 16; j++) {

	        			B.port_state = (dma_buffer.data[i] >> j) & 0x01; // Extract bit i
	        			xQueueSend(dmaQueue[j], &B, 0);
	        			//B.timestamp = dma_buffer.timestamp;
	        		}
//	        		dmadata.data[i]=dma_buffer.data[i];
//	        		xQueueSend(dmaQueue, &dma_buffer, 0);//0 tells the compiler how long to wait  (10 - 10 ms)
	        	}
	        }
	    }
}




void ProcessingTask(void *pvParameters)
{
	if (xQueueReceive(dmaQueue, &B, portMAX_DELAY) == pdTRUE)
	{
//		uint16_t state = dmadata.data;  // 16-bit GPIO states
//
//		for (uint8_t i = 0; i < 16; i++) {
//		    B[i].port_state = (dmadata.data >> i) & 0x01; // Extract bit i
//		    B[i].timestamp = dmadata.timestamp;
		}

	}


 void CommunicationTask(void *pvParameters)
{

}


 uint32_t SystemCoreClock=8400000;


int main(void)
{

	clock_setup();

	BaseType_t status;


	status =usart_setup();
	configASSERT(status == pdPASS);  // Ensure creation succeeded

	status =timer_init(TIM2);
		configASSERT(status == pdPASS);  // Ensure creation succeeded


	    // Create Acquisition Task
	    status = xTaskCreate(
	        AcquisitionTask,
	        "Acquisition",
	        ACQUISITION_TASK_STACK_SIZE,
	        NULL,
	        ACQUISITION_TASK_PRIORITY,
	        &acquisitionTaskHandle
	    );
	    configASSERT(status == pdPASS);  // Ensure creation succeeded

	    // Create Processing Task
	    status = xTaskCreate(
	        ProcessingTask,
	        "Processing",
	        PROCESSING_TASK_STACK_SIZE,
	        NULL,
	        PROCESSING_TASK_PRIORITY,
	        &processingTaskHandle
	    );
	    configASSERT(status == pdPASS);

	    // Create Communication Task
	    status = xTaskCreate(
	        CommunicationTask,
	        "Comm",
	        COMM_TASK_STACK_SIZE,
	        NULL,
	        COMM_TASK_PRIORITY,
	        &commTaskHandle
	    );
	    configASSERT(status == pdPASS);

	    dmaSemaphore = xSemaphoreCreateBinary();
	    configASSERT(dmaSemaphore != NULL);  // Always check


	        for (uint8_t i = 0; i < 16; i++) {
	        	dmaQueue[i] = xQueueCreate(10, ITEM_SIZE); // Stores just port_state
	            if (dmaQueue[i] == NULL) {
	            	 configASSERT(dmaQueue[i] != NULL);
	                // Handle error
	            }
	        }


//	    dmaQueue = xQueueCreate(QUEUE_LENGTH, ITEM_SIZE);
//	    configASSERT(dmaQueue != NULL);

	    uartQueue = xQueueCreate(PROTOCAL_STRUCT_SIZE, ITEM_SIZE);
	    	    configASSERT(dmaQueue != NULL);


	    // Start scheduler
	    vTaskStartScheduler();
}


//void DMA1_Streamx_IRQHandler(void)
//{
//    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
//
//    // Check if transfer complete interrupt occurred
//    if (DMA_GetITStatus(DMA1_Streamx, DMA_IT_TCIFx))
//    {
//        DMA_ClearITPendingBit(DMA1_Streamx, DMA_IT_TCIFx);
//
//        // Give semaphore to unblock the task
//        xSemaphoreGiveFromISR(dmaSemaphore, &xHigherPriorityTaskWoken);
//
//        // Context switch if needed
//        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
//    }
//}

//  7   6    5  4  3  2    1  0
//[  TYPE  |   CATEGORY   | ID ]

typedef enum {
    // Config Set Commands
    CMD_CFG_SET_SPI      = 0x10,
    CMD_CFG_SET_I2C      = 0x11,
    CMD_CFG_SET_UART     = 0x12,

    // Config Get Commands
    CMD_CFG_GET_SPI      = 0x20,
    CMD_CFG_GET_I2C      = 0x21,
    CMD_CFG_GET_UART     = 0x22,

    // Capture Commands
    CMD_CAP_START        = 0x30,
    CMD_CAP_STOP         = 0x31,

    // Period Set/Get
    CMD_PRD_SET_PERIOD   = 0x40,
    CMD_PRD_GET_PERIOD   = 0x41,

    // Data Transfer
    CMD_DATA_DECODED     = 0x50,
    CMD_DATA_RAW         = 0x51,

    // Error Messages
    CMD_ERR_GENERAL      = 0x60,
    CMD_ERR_INVALID_CMD  = 0x61,
    CMD_ERR_TIMEOUT      = 0x62

    // You can keep expanding
} CommandCode_t;

// use this approch in processing to determine which communication and what to process
//typedef enum {
//    MSG_TYPE_ADC,
//    MSG_TYPE_UART,
//    MSG_TYPE_ERROR
//} MsgType_t;
//
//typedef struct {
//    MsgType_t type;
//    union {
//        struct {
//            uint16_t value;
//            uint8_t channel;
//        } adc;
//
//        struct {
//            char text[32];
//        } uart;
//
//        struct {
//            int code;
//        } error;
//    } data;
//} SystemMessage_t;
//void MessageProcessingTask(void *params)
//{
//    SystemMessage_t msg;
//
//    for (;;)
//    {
//        if (xQueueReceive(systemQueue, &msg, portMAX_DELAY) == pdTRUE)
//        {
//            switch (msg.type)
//            {
//                case MSG_TYPE_ADC:
//                    handle_adc(msg.data.adc.value, msg.data.adc.channel);
//                    break;
//
//                case MSG_TYPE_UART:
//                    handle_uart(msg.data.uart.text);
//                    break;
//
//                case MSG_TYPE_ERROR:
//                    handle_error(msg.data.error.code);
//                    break;
//            }
//        }
//    }
//}






